#+TITLE: Representing and Manipulating Information

* Information Storage
计算机中最小的可寻址内存单位是字节(byte），1 byte = 8 bit,机器级程序将
内存视为一个非常大的字节数组，称为虚拟内存(virtual memory)。内存的每
个字节都由一个唯一的数字来标识，称为它的地址(address),而所有可能地址的
集合就称为虚拟地址空间(virtual address space),
** 十六进制表示法
由于计算机的bit 是由二进制表示，所以我们通常使用的十进制数在计算机中并
不是很方便使用，因为十进制与二进制数之间的转换很麻烦，而直接使用二进制
表示法又太冗长，因此在计算机中十六进制(hexadecimal)数被广泛用于表示位
模式，它用‘0’～‘9’以及‘A’～‘F’来表示可能的值，分别对应(0~15)_10
一个十六进制数可以展开为4个二进制数，如0x0=0000,0xF=1111.也就是说一个
十六进制数占用4个位（bit），一个字节可以保存2个十六进制数。
** 字大小
每台计算机都有一个字长(word size)，指明指针数据的标称大小(normal
size),字长的最直接影响是内存地址的跨度，即相邻两个地址之间的差。
一个字长通常为32位或64位，“32位程序”或“64位程序”区别在于该程序是如何编
译的而不是其运行的机器类型。
** 寻址和字节顺序
对于跨越多字节的程序对象(数据，指令，控制信息)，我们必须建立两个规则：
+ 这个对象的地址是什么 :: 多字节对象都被存储在连续的字节序列，对象的地
                址为所使用字节中最小的地址
+ 在内存中如何排列這些字节 :: 大端法和小端法。
大端法：最高有效字节在最前面；小端法：最低有效字节在最前面。

比如变量x 的类型为int,位于地址0x100处，它的十六进制值为0x01234567,地址
范围0x100~0x103(从左至右排列)的字节顺序依赖于机器的类型：
#+BEGIN_SRC plantuml :file figures/C.png :exports results
@startuml
digraph structs {
subgraph cluster_big{//子图必须以cluster*
label = "大端法";
labeljust = l;
labelloc = t;
big_endian [shape = record, label = "|...|01|23|45|67|...|",comment="big_endian"];
}

subgraph cluster_lit{
label = "小端法";
labeljust = l;
labelloc = t;
little_endian [shape = record,label = "|...|67|45|23|01|...|"];
}
}
@enduml
#+END_SRC
大多数Intel 兼容机都只用小端模式。
问题：如何编程判断你的系统是大端法还是小端法？
参考：
#+BEGIN_EXAMPLE
bool big_little(){//大端则返回true,否则返回false
int i = 1;
if((char*)&i[3] == 1)
return true;
else
retun false;
}
#+END_EXAMPLE
** C 语言位级运算
AND(&),NOT(~),OR(|),XOR(^)
** C 语言逻辑运算
AND(&&),OR(||),NOT(!)
** C 预言中移位运算
右移(>>),左移(<<).
x<<k:是将x(w bit) 向左移动k 位，丢弃最高的k位，并在右端补k 个0,k 应该是在
0~w-1之间的值。
x>>k:是将x(w 位)向右移动k 位。分为逻辑右移和算术右移。逻辑右移在左边补
k 个0,算术右移在左端补k 个最高有效位的值。
| 操作        | 值                    |
|-------------+-----------------------|
| 参数x       | [01100011] [10010101] |
| x<<4        | [00110000] [01010000] |
| x>>4(logic) | [00000110] [00001001] |
| x>>4(算术)  | [00000110] [11111001] |
C 预言标准并没有明确定义对于有符号数应该使用哪种类型的右移，而几乎所有
的编译器/机器组合都对有符号数使用算术右移，而对于无符号数必须使用逻辑
右移。

* Integer Representations
整数分为有符号整数和无符号整数两种。
** 整型数据类型
| C Data type      | 64-bit size(byte) | 32-bit size(byte) |
|------------------+-------------------+-------------------|
| (unsigned)char   |                 1 |                 1 |
| (unsigned)short  |                 2 |                 2 |
| (unsigned)int    |                 4 |                 4 |
| (unsigned)long   |                 8 |                 4 |
| int32_t/uint32_t |                 4 |                 4 |
| int64_t/uint64_t |                 8 |                 8 |
不同类型的整数的取值范围也是不同的，如果一个整数占据w 位，那么该类型的
有符号类型的取值范围是－2^{w-1}-1 ~ 2^{w-1}-1 .无符号类型的取值范围是
0~2^w-1.
** 无符号数的编码
假设一个整数类型有w 位，位级表示为[x_{w-1},x_{w-2},...,x_0],每一位x_i
取值为0或1,我们用函数B2U_w(Binary to Unsigned,w bit)来表示：
\begin{equation}
B2U_w=\sum_{i=0}^{w-1} 2^i * x_i
\end{equation}

可知，最大值UMax_w=2^w-1,最小值UMin_w=0.
** 补码编码 （two's complement）
虽然C 标准并未规定有符号数采用什么编码方式，但是目前绝大部份的机器都使
用补码来表示有符号数，补码编码的一个特征是最高有效位作为符号位。
\begin{equation}
B2T_w=\sum_{i=0}^{w-2} 2^i * x_i + 2^{w-1} * x_{w-1}
\end{equation}

其最大值为当x_{w-1}=0时，即TMax_w=2^{w-1}-1,最小值为当x_{w-1}=1时，即
TMin_w=-2^{w-1}。
** 有符号与无符号的转换
在计算机内部，所有的信息都是0/1序列，不同的是计算机用什么编码方式去解
释這些序列，因此有符号和无符号数的区别就是计算机采用不同的编码方式去解
释数字序列。有符号与无符号的转换遵循数字位级表示的每一位x_i 不变，而只
改变编码方式。
有符号数与无符号数的差别主要在最高位的符号位上，因此在两者进行转换时也
是主要考虑符号位。
给定一个w 位的数字，我们可以用无符号和有符号编码规则去解释它，现在我们
需要找出在相同位模式下，有符号数和无符号数的关系。
1. 如果第 =w-1= 位为0,那么有符号数与无符号数的表示是相同的，取值范围
   [0,TMax].此时有符号数与无符号数数值相等。
2. 如果第 =w-1= 位为1,那么解释为有符号数为负数，解释为无符号数为
   (TMax,UMax].此时有符号数与无符号数数值需要转换：
U -> T: u-2^w

T -> U: t+2^w
#+BEGIN_SRC plantuml :file figures/TUConvert.png :exports results
@startditaa

             +----------------------------------------------------+
             |                                                    |
|            v        0  |                        |               |
+------------------------+------------------------+               |
TMin           |         .      |          ^      .   TMax        |
               |         .      |          |      .               |
               |         .      |          |      .               |
               |                |          |      .               |
               |         |      v          |                      |        |
               |         +-------------------------------------------------+
               |        UMin                                ^           UMax
               |                                            |
               +--------------------------------------------+
#+END_SRC

在C++语言中有以下几种类型转换：
1. 显式的强制类型转换
2. 隐式类型转换

  在下面这些情形下，编译器会自动的转换运算对象的类型：
  + 大多数表达式中，比int 类型小的整型值首先提升为较大的整数类型
  + 在条件句中，非布尔值转换为布尔值
  + 初始化过程中，初始值转换为变量的类型；在赋值语句中，右侧运算对象转
    换为左侧运算对象的类型。
  + 如果算术运算或关系运算的操作数有多钟类型，需要转换为同一类型后在执
    行运算，通常是“小”的提升为“大”的。特别需要注意的是如果两个操作数一
    个是有符号的，一个是无符号的，那么有符号的要转换为无符号的数。
** 改变一个数字的位表示
一个常见得操作是在不同得字长得整数之间转换。通常有扩展一个数字得位表示
和截断数字。
*** 扩展
+ 无符号数的零扩展 :: 零扩展：扩展位放在左边，填充0.
+ 补码数的符号扩展 :: 符号扩展：扩展位放在左边，填充补码数的符号位数字。
扩展一个数字的位模式可以保证不改变这个数字的数值。
*** 截断
截断数字就是减少一个数字的位表示，比如从w 位截断到k 位，不论是无符号数
还是补码数，计算机都会直接丢弃高(w-k)位，相当于 x mod 2^k ,然后计算机
对剩余的k 位进行无符号或者补码方式解读。
当截断一个数字时有可能会改变原数字的值，取决于 (w-k)位的位模式。

*** 符号与位表示的改变顺序
当我们对一个数字在一个表达式内进行符号和位表示的改变时，这两个变化的顺
序是什么？
: short sx = -12345;
: unsigned uy = sx;
C预言规定先改变大小，之后进行符号的转换。

* Integer Arithmetic
溢出（overflow）：完整的整数结果不能放到规定的数据类型中去。研究溢出需
要有两个视角，一个是纯数学的角度，满足四则运算法则，另一个角度是计算机
的角度，计算机只关心特定位模式下数字的解读。
** 无符号加法
假设两个非负整数x,y⊂[0,2^w-1],那么x+y⊂[0,2^{w+1}-2],结果需要w+1位来存
储，然而该整数类型只有w 位，因此结果有可能会溢出，我们接下来将讨论溢出
以后的情形和如何判断溢出。
我们将计算机得到的x+y 的结果记为z,这个z 不是数学上x+y 的结果，而是有可
能发生了溢出。
#+BEGIN_SRC plantuml :file figures/UOverflow.png :exports results
@startditaa
              +--------------------------------+
z:            |                                |
  |           v            |                   |
 0+------------------------+                   |
  |                        |                   |
                                               |
           NORMAL           .        OVERFLOW  |
                            .                  |
x+y                         .                  |
  |                         .                  |     |
0 +--------------------------------------------------+
  |                                                  |


@endditaa
#+END_SRC
结果是否溢出主要看其是否超出了数据类型能表示的最大值与最小值，如果发生
了溢出，那么从二进制表示上来说，计算机会将超出的那一位直接丢弃，即w+1
位，2^w;而只保留剩下的w 位，从十进制角度来说，这个过程相当于做了一次求余，
除数是2^w。
    \begin{equation}
    z=\left\{
    \begin{aligned}
    x+y & , & if & & x+y < 2^w && NORMAL \\
    x+y-2^w & , & if & & x+y ≥ 2^w && OVERFLOW
    \end{aligned}
    \right.
    \end{equation}

下面牵出两个问题，两个正整数相加如何判断已经发生了溢出？以及两个正整数
在什么条件下相加为0?
首先通过观察z 的计算公示，如果没有发生溢出，那么z 肯定比x 和y 都要大，
而如果发生了溢出，那么z 肯定比x 和y 的任何一个都要小，因此只需要判断
z<x(y) 是否为真，为真则溢出，否则没溢出。
两个正整数相加为0应该满足x+y=2^w 或者x=y=0。
** 补码加法
无符号加法只需要考虑结果是否超出了数据类型的上限，而补码加法还需要考虑
结果是否超出了下限，只要超出了这两个界限那么就会发生溢出。
#+BEGIN_SRC plantuml :file figures/TOverflow.png :exports results
@startditaa
                 NEGATIVE OVERFLOW                           NORMAL                          POSITIVE OVERFLOW
     x+y:     |                        |                        |                        |                        |
    (Math)    +------------------------+------------------------+------------------------+------------------------+
              |                      | |                        |                        | |                      |
                                     |                          0                          |
                                     +------------------------------------------------+    |
                                        +---------------------------------------------+----+
                                        |                                             |
        z:                             |v                       |                     v  |
   ( Computer)                         +------------------------+------------------------+
                                       |                        |                        |
                                      TMin                      0                       TMax
                                   [10...0]                                            [011...1]
                                                               w bits
                                                         [00...00]~[11...11]
@endditaa
#+END_SRC

有符号数的溢出可以这样的动态的演示一遍：
*** 正溢出
给定一个int 型变量，从0开始累加1:
: int t = 0;
: t += 1;
变量 =t= 会向着 =TMax= 方向移动，在到达 =TMax= 点前都属于 /NORMAL/ ,当
变量 =t= 到达 =TMax= 以后，再累加1,此时结果已经超出了int 类型所能表示
的最大值，此时已经发生了溢出，因为是在正数区域发生的溢出，因此称为正溢
出，而计算机此时却将结果解释为 =TMin= .然后继续累加1，直到2^32-1点，计
算机将这一点解读为－1,因为所有位上的值均为1,这是一个特殊点，此时继续加1,从数
学的角度讲－1+1=0这是事实，但是看看计算机是如何实现的：t 的所有32位全
变为0,并向前进一位，计算机只读取它关心的那32位，因此结果为0.此时t 回到
原点。
*** 负溢出
假设 =t= 一开始是向 =TMin= 的方向移动会发生什么呢：
: int t = 0;
: t -= 1;
=t= 首先再[TMin,0]的区域的变化是正常的，当计算 =TMin-1= 时，计算机的结
果与数学的结果出现了分歧：由于位模式变为 [011...1],计算机将它解读位
=TMax=,很显然这是与数学不相符的，因此这个时候发生了溢出，我们叫做负溢
出。


因此可以总结一下补码加法的计算公式：
    \begin{equation}
    z=\left\{
    \begin{aligned}
    x+y & , & if & & -2^{w-1} ≤ x+y < 2^{w-1} && NORMAL \\
    x+y-2^w & , & if & & x+y ≥ 2^{w-1} && POSITIVE OVERFLOW\\
    x+y+2^w & , & if & & x+y < -2^{w-1} && NEGTIVE OVERFLOW
    \end{aligned}
    \right.
    \end{equation}
如何判断补码溢出？从上面的正负溢出可以看到一个规律，当发生正溢出时，两
个操作数都为正，而结果为负；当发生负溢出时，两个操作数均为负，而结果却
为正；当两个操作数异号时是不可能发生溢出的。
两个补码数在什么条件下相加为0? 首先TMin+TMin = 0;如果有一个补码数不为
TMin,x+(-x)=0.
其实无论是补码数还是无符号数，已知一个数的情况下求它的加法逆元（相加为
零的数）完全可以从溢出的角度考虑： [xx...xx]+[yy...yy]=[1][00...00].等
号左边表示两个数字的位模式，等号右边的 [1]表示进一位， [00...00]表示有
效位模式均为0,因此如果已知x,共有w 位，要求它的逆元可以直接2^w-x 求得；
另外也可以对x 进行位非（～）操作加1获得，即 *x+(~x+1)=0* 。
** 乘法
无论是无符号数还是补码数，做乘法以后的结果需要2w 位来存储，但计算机会
截断到w 位，相当于 (x*y) mod 2^w ,然后计算机再根据数据类型来解读结果是
无符号还是补码数。
** 乘以常数
这个常数应该是字面值常量。这种乘法可以转换为移位操作和加减运算。左移1
位相当于乘2.因此常数可以分解为若干个2的不同次幂的和（差），比如x*14 可
以分解为x*(2^4-2^1),因此可以转换为 (x<<4)-(x<<1).
** 整数除法
整数除法向零舍入，即直接舍掉小数部分（对正负结果均有效）
* Floating Point
浮点数对于形如V=(-1)^s×M×2^E 的有理数进行编码。它可以表示的范围非常大。
- 符号位 :: s:决定正负号
- 尾数 :: M:一个二进制小数，
- 阶码 :: E:对浮点数的加权，可以是正数，也可以是负数。
以下是以上三个变量在单精度和双精度浮点数中的比重：
|       | 单精度浮点数 | 双精度浮点数 |
|-------+--------------+--------------|
| s:E:M |       1:8:23 |      1:11:52 |
在C语言中float 对应单精度浮点数（32位），double 对应双精度浮点数
（64位）。
** 二进制小数
[b_m,b_{m-1},...b_2,b_1,b_0.b_{-1},b_{-2},b_{-3},...b_{-n+1},b_{-n}]
\begin{equation}
b=\sum_{i=-n}^{m} 2^i×b_i
\end{equation}

二进制小数只能精确的表示那些能写成x*2^y 形式的数字，其它的只能近似表示，
** 舍入
因为表示方法限制了浮点数的范围和精度，所以浮点运算只能近似的表示实数运
算。对于值x,我们一般希望用一种系统的方法，能够找到最接近的匹配值x',它
可以用期望的浮点形式表示出来，这就是舍入（rounding）运算的任务。一个关
键的问题就是在两个可能值的中间确定舍入的方向。
IEEE 浮点数定义了四种不同的舍入方式，默认的是向偶数舍入。
| 方式       | 1.40 | 1.60 | 1.50 | 2.50 | -1.50 |
|------------+------+------+------+------+-------|
| 向偶数舍入 |    1 |    2 |    2 |    2 |    -2 |
| 向零舍入   |    1 |    1 |    1 |    2 |    -1 |
| 向下舍入   |    1 |    1 |    1 |    2 |    -2 |
| 向上舍入   |    2 |    2 |    2 |    3 |    -1 |
向偶数舍入与四舍五入的关系：这两种方式只在处理1.5,2.5这样的中间值时有
区别，在处理中间值时，四舍五入方法会进位，而向偶数舍入方式会使得结果的
最低有效数字是偶数，这种舍入方式在统计数据时引入的统计偏差最小，因为它
有一半的概率向上舍入，有一半的向下舍入。而不像其它的舍入方式一样，都向
一个方向舍入。
对于小数的向偶数舍入也是一样，比如保留两位小数，对1.23499999和1.2350000001分别向偶数舍
入到1.23和1.24(因为源数据不是中间值，所以与四舍五入一样).对1.2350000和
1.2450000舍入到1.24(因为4是偶数)
相似的，向偶数舍入法也能应用到二进制小数上。我们将最低有效位的值0认为
是偶数，值1认为是奇数。如何判断二进制小数的中间值？参考十进制数的中间
值是5= /10/ /2,那么二进制小数的中间值应该是1= /2/ /2,因此向偶数舍入只有对形如
XXX***X.YY***Y100***的二进制位模式有效，X,Y为任意位值，最右边的Y为要被
舍入的位置，最后的*代表0.
举例：要求保留小数点后3位。

对于1.0011001，舍入处理后为1.010（去掉多余的4位，加0.001）
对于1.0010111，舍入处理后为1.001（去掉多余的4位）
对于1.0011000，舍入处理后为1.010（去掉多余的4位，加0.001，使得最低位为0）

对于1.1001001，舍入处理后为1.101（去掉多余的4位，加0.001）
对于1.1000111，舍入处理后为1.100（去掉多余的4位）
对于1.1001000，舍入处理后为1.100（去掉多余的4位，不加，因为最低位已经为0）

对于1.01011，舍入处理后为1.011（去掉多余的2位，加0.001）
对于1.01001，舍入处理后为1.010（去掉多余的2位）
对于1.01010，舍入处理后为1.010（去掉多余的2位，不加）

对于1.01111，舍入处理后为1.100（去掉多余的2位，加0.001）
对于1.01101，舍入处理后为1.011（去掉多余的2位）
对于1.01110，舍入处理后为1.100（去掉多余的2位，加0.001）
最近舍入模式在C/C++中没有相应的函数，当然，IEEE754以及x86 FPU的默认舍入模式是最近舍入，也就是每次浮点计算结果都采用最近舍入模式，除非用程序显式设置为其它三种舍入模式。 另外三种舍入模式，简要说明。

向0（截断）舍入：C/C++的类型转换。(int) 1.324 = 1，(int) -1.324 = -1;

向负无穷大（向下）舍入：C/C++函数floor()。例如：floor(1.324) = 1，floor(-1.324) = -2。
向正无穷大（向上）舍入：C/C++函数ceil()。ceil(1.324) = 2。ceil(-1.324)
= -1;

当在int,float,double 格式之间进行强制类型转换时，程序改变数值和位模式
的原则如下（假定int 是32位）：
- 从int 转换成float,数字不会溢出，但可能被舍入
- 从int,float 转换成double,因为double 有更大的范围（也就是可表示值的范
  围），也有更高的精度（也就是有效位数），所以能够保留精确的数值。
- 从double 转换成float,因为范围要小一些，所以值可能溢出成＋∞或－∞，另
  外由于精度较小，它还可能被舍入。
- 从float,double 转换成int,值将会向零舍入。还有可能会溢出。与Intel 兼
  容的微处理器指定位模式 [100...0](字长为w 的TMin_w)为整数不确定值，一
  个浮点数往整数转换，如果不能找到一个合理的整数近似值，就会产生一个这
  样的值。
由于C/C++对于float 和double 类型的处理速度差别很小，所以尽可能的使用
double 类型
* 相关知识

** 整型提升（integral promotion）
整型提升负责把小整数类型转换成较大的整数类型。对于bool,char,unsigned
char,signed char,unsigned short,short等类型，只要它们所有可能的值能够
存在int 里，它们就会提升成为int,否则提升成unsigned int,比如 =false= 提升
为0, =true= 提升为1。
较大的char 类型（wchar_t,char16_t,char32_t）提升为（unsigned）
int,(unsigned)long,(unsigned)long long 中最小的一种类型，前提是转换后
的类型要能容纳原类型所有可能的值。（Primer C++ 5th 4.11.1）
